> Java by 유종원
> 수정 및 배포, 상업적 사용을 금지합니다.

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [클래스 사용법](#클래스-사용법)
    - [클래스를 만드는 방법](#클래스를-만드는-방법)
    - [클래스를 생성하는 방법](#클래스를-생성하는-방법)
    - [클래스에 함수를 정의하고 호출하는 방법](#클래스에-함수를-정의하고-호출하는-방법)
    - [메서드 호출 시에 값을 전달하고, 전달받는 방법](#메서드-호출-시에-값을-전달하고-전달받는-방법)
    - [클래스에 변수를 선언하고 사용하는 방법](#클래스에-변수를-선언하고-사용하는-방법)
- [우선순위 큐 : 힙 (Priority Queue : Heap)](#우선순위-큐--힙-priority-queue--heap)
    - [개요](#개요)
    - [힙에 값을 추가하는 과정](#힙에-값을-추가하는-과정)
    - [힙에서 값을 제거하는 과정](#힙에서-값을-제거하는-과정)
    - [구현하기](#구현하기)

<!-- /code_chunk_output -->

# 클래스 사용법
클래스는 관련있는 변수들과 함수들을 하나로 묶어 이름을 붙이는 기능이다.

### 클래스를 만드는 방법
다음은 오류가 없는 최소한의 자바 프로그램이자, T 라는 이름의 클래스를 만드는 프로그램이다.
```java
// T 라는 이름의 클래스를 만든다.
class T
{
  public static void main(String[] args)
  {
  }
}
```
자바는 모든 것이 클래스 기반이므로, 우리는 지금까지 항상 클래스를 만들어왔던 셈이다. 위 프로그램을 실행하면 프로그램이 그저 오류없이 실행되었다가 종료된다. 클래스를 만드는 것 자체로는 아무런 동작도 하지 않는다. 클래스를 사용하기 위해서는 만든 클래스를 별도로 생성해야 한다. 클래스를 만드는 것을 클래스를 `정의`한다고 한다.

### 클래스를 생성하는 방법
정의한 클래스를 생성하는 방법은 다음과 같다.
```java
class T
{
  public static void main(String[] args)
  {
    var t = new T();  // T 클래스를 생성해 t 라는 이름의 변수의 초기값으로 설정한다.
  }
}
```
위 프로그램에서 클래스를 생성하는 코드는 `var t = new T();`의 `new T()`다. 생성된 클래스는 그 자체가 값이므로 어떤 숫자 하나 혹은 변수 하나와 같다. 생성한 클래스를 `인스턴스`라고 한다.

### 클래스에 함수를 정의하고 호출하는 방법
클래스 안에 함수를 정의하고 호출하는 방법은 다음과 같다.
```java
class T
{
  // T 클래스에 f 라는 이름의 함수를 정의한다.
  void f()
  {
    System.out.println(0);
  }

  public static void main(String[] args)
  {
    var t = new T();
    t.f();  // T 클래스의 인스턴스인 t 로 T 클래스에 포함된 f 라는 이름의 함수를 실행한다.
  }
}
```
* 실행 결과
```
0

```
위 프로그램에서와 같이 클래스에 속하는 함수는 인스턴스를 가지고 호출한다. `t.f();`의 `.`가 인스턴스의 클래스에 속한 것을 사용하겠다는 의미다. 클래스에 속하는 함수를 `메서드`라고 한다.

### 메서드 호출 시에 값을 전달하고, 전달받는 방법
메서드는 클래스에 속해있을 뿐 함수와 같다. 함수 이름 뒤의 `(` 와 `)` 사이에 변수를 선언해 값을 전달받을 수 있다.
```java
class T
{
  // a, b, c 라는 이름의 변수를 선언해 숫자 세 개를 전달받는다.
  void f(int a, int b, int c)
  {
    System.out.println(a);  // 매개변수 a의 값을 출력한다.
    System.out.println(b);  // 매개변수 b의 값을 출력한다.
    System.out.println(c);  // 매개변수 c의 값을 출력한다.
  }

  public static void main(String[] args)
  {
    var t = new T();
    t.f(0, 1, 2);     // f 메서드를 호출하면서 숫자 1, 2, 3을 전달한다.
  }
}
```
* 실행 결과
```
0
1
2

```

### 클래스에 변수를 선언하고 사용하는 방법
클래스 안에 변수를 만들고 사용하는 방법은 다음과 같다.
```java
class T
{
  int a = 0;    // T 클래스에 숫자 0을 값으로 하는 a 라는 이름의 변수를 선언한다.

  void setA(int a)
  {
    this.a = a; // T 클래스의 a 변수의 값을 매개변수 a의 값으로 변경한다.
  }

  void printA()
  {
    System.out.println(a);  // T 클래스의 a 변수의 값을 출력한다.
  }

  public static void main(String[] args)
  {
    var t = new T();
    t.printA();
    t.setA(1);
    t.printA();
  }
}
```
* 실행 결과
```
0
1

```
위 프로그램에서와 같이 클래스에 속하는 변수는 클래스의 `{` 와 `}` 의 사이에 선언한다. 그리고 `this.a = a;` 코드의 `this.a` 코드와 같이 `this`를 가지고 변수의 값을 바꾸거나 읽는다. `this.a`의 `.`가 클래스에 속한 것을 사용하겠다는 의미다. 클래스 안에 선언된 변수를 `멤버변수`라고 한다.

# 우선순위 큐 : 힙 (Priority Queue : Heap)
값을 넣은 순서와 관계없이 어떤 조건에 따른 순서대로 값이 나오는 자료구조를 우선순위 큐라고 한다. 우선순위 큐는 힙을 사용해 구현한다. 값들을 어떤 조건에 따라 정렬한 상태로 유지하는 자료구조를 힙이라고 한다. 힙은 배열을 사용해 구현한다.

### 개요
`PriorityQueue`라는 이름의 클래스를 만드는 것이 목표다. 다음은 클래스의 주요 메서드다.

|메서드|설명|
|-|-|
|push()|값을 추가한다.|
|pop()|가장 큰 값을 꺼내 반환한다.|

사용법과 동작 방식은 다음과 같다.
```py
q = PriorityQueue()
q.push(5)
q.push(1)
q.push(4)
q.push(9)
print(q.pop())
print(q.pop())
print(q.pop())
print(q.pop())
```
* 실행 결과
```
9
5
4
1

```

### 힙에 값을 추가하는 과정
새로운 값을 마지막 노드로 추가하고, 부모의 값이 더 작으면 교환하는 것을 반복해 힙을 유지한다.
* `[_, _, _, _, _]` 는 크기가 5인 배열을 나타낸다. `_`는 값이 없음을 표현한다.
* `length`는 배열에 담긴 값의 개수를 나타낸다.
```py
[_, _, _, _, _] # length = 0

[1, _, _, _, _] # length = 1, 힙에 숫자 1을 마지막 노드로 추가했다.
        1

[1, 2, _, _, _] # length = 2, 힙에 숫자 2를 마지막 노드로 추가했다.
        1
      /
    2

[2, 1, _, _, _] # length = 2, 힙을 유지하기 위해 부모 노드와 교환했다.
        2
      /
    1

[2, 1, 3, _, _] # length = 3, 힙에 숫자 3을 마지막 노드로 추가했다.
        2
      /   \
    1       3

[3, 1, 2, _, _] # length = 3, 힙을 유지하기 위해 부모 노드와 교환했다.
        3
      /   \
    1       2

[3, 1, 2, 4, _] # length = 4, 힙에 숫자 4를 마지막 노드로 추가했다.
        3
      /   \
    1       2
   /
  4

[3, 4, 2, 1, _] # length = 4, 힙을 유지하기 위해 부모 노드와 교환했다.
        3
      /   \
    4       2
   /
  1

[4, 3, 2, 1, _] # length = 4, 힙을 유지하기 위해 부모 노드와 교환했다.
        4
      /   \
    3       2
   /
  1

[4, 3, 2, 1, 5] # length = 5, 힙에 숫자 5를 마지막 노드로 추가했다.
        4
      /   \
    3       2
   / \
  1   5

[4, 5, 2, 1, 3] # length = 5, 힙을 유지하기 위해 부모 노드와 교환했다.
        4
      /   \
    5       2
   / \
  1   3

[5, 4, 2, 1, 3] # length = 5, 힙을 유지하기 위해 부모 노드와 교환했다.
        5
      /   \
    4       2
   / \
  1   3
```

### 힙에서 값을 제거하는 과정
마지막 노드를 루트로 올려 가장 큰 값을 제거하고, 자식의 값이 더 크면 교환하는 것을 반복해 힙을 유지한다.
```py
[5, 4, 2, 1, 3] # length = 5
        5
      /   \
    4       2
   / \
  1   3

[3, 4, 2, 1, _] # length = 4, 마지막 노드를 루트로 올려 가장 큰 값을 제거했다.
        3
      /   \
    4       2
   /
  1

[4, 3, 2, 1, _] # length = 4, 힙을 유지하기 위해 루트를 두 자식 중 큰 값과 교환했다.
        4
      /   \
    3       2
   /
  1

[1, 3, 2, _, _] # length = 3, 마지막 노드를 루트로 올려 가장 큰 값을 제거했다.
        1
      /   \
    3       2

[3, 1, 2, _, _] # length = 3, 힙을 유지하기 위해 루트를 두 자식 중 큰 값과 교환했다.
        3
      /   \
    1       2

[2, 1, _, _, _] # length = 2, 마지막 노드를 루트로 올려 가장 큰 값을 제거했다.
        2
      /
    1

[1, _, _, _, _] # length = 1, 마지막 노드를 루트로 올려 가장 큰 값을 제거했다.
        1
```

### 구현하기
```java
class PriorityQueue {
  int length = 0;
  Integer[] a = new Integer[10];

  void push(int value) {
    // 힙에 값을 추가하는 코드를 작성하자.
  }

  int pop() {
    // 우선순위가 가장 높은 값을 힙에서 제거해 반환하는 코드를 작성하자.
  }

  int peek() {
    // 우선순위가 가장 높은 값을 힙에서 제거하지 않고 반환하는 코드를 작성하자.
  }

  boolean empty() {
    // 힙에 값이 있는지의 여부를 반환하는 코드를 작성하자.
  }

  int length() {
    // 힙에 있는 값의 개수를 반환하는 코드를 작성하자.
  }

  void clear() {
    // 힙을 초기화하는 코드를 작성하자.
  }

  void print() {
    // 힙의 값들을 순서대로 출력하는 코드를 작성하자.
  }

  public static void main(String[] args) {
    var q = new PriorityQueue();
  }
}
```
